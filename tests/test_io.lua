-- I/O round-trip tests for ipynb.nvim
-- Ensures notebooks are read and written without corruption
-- Run with: nvim --headless -u tests/minimal_init.lua -l tests/test_io.lua

local h = require('tests.helpers')

print('')
print(string.rep('=', 60))
print('Running I/O round-trip tests')
print(string.rep('=', 60))
print('')

local io_mod = require('ipynb.io')

--------------------------------------------------------------------------------
-- Source splitting tests (must match nbformat behavior)
-- Expected values generated by: uv run python tests/test_source_splitting.py
--------------------------------------------------------------------------------

-- Test cases: { name, source, expected_lines }
-- Expected values are from nbformat's actual output
local SOURCE_SPLIT_CASES = {
  { 'empty', '', {} },
  { 'single_line', 'x = 1', { 'x = 1' } },
  { 'single_line_trailing_newline', 'x = 1\n', { 'x = 1\n' } },
  { 'multi_line', 'x = 1\ny = 2', { 'x = 1\n', 'y = 2' } },
  { 'multi_line_trailing_newline', 'x = 1\ny = 2\n', { 'x = 1\n', 'y = 2\n' } },
  { 'three_lines', 'a\nb\nc', { 'a\n', 'b\n', 'c' } },
  { 'three_lines_trailing', 'a\nb\nc\n', { 'a\n', 'b\n', 'c\n' } },
  { 'blank_line_middle', 'a\n\nb', { 'a\n', '\n', 'b' } },
  { 'only_newline', '\n', { '\n' } },
  { 'multiple_newlines', '\n\n', { '\n', '\n' } },
  { 'unicode_emoji', 'ðŸŽ‰ = "party"', { 'ðŸŽ‰ = "party"' } },
  { 'unicode_japanese', 'x = "æ—¥æœ¬èªž"', { 'x = "æ—¥æœ¬èªž"' } },
}

-- Helper to compare arrays
local function arrays_equal(a, b)
  if #a ~= #b then
    return false, string.format('length mismatch: %d vs %d', #a, #b)
  end
  for i = 1, #a do
    if a[i] ~= b[i] then
      return false, string.format('element %d: %q vs %q', i, a[i], b[i])
    end
  end
  return true
end

-- Helper to get source lines from a written notebook
local function get_written_source_lines(source)
  local cells = {{ source = source, type = 'code', metadata = {}, outputs = {} }}
  local temp_path = vim.fn.tempname() .. '.ipynb'
  io_mod.write_ipynb(temp_path, cells, { nbformat = 4, nbformat_minor = 5 })

  local content = table.concat(vim.fn.readfile(temp_path), '\n')
  local notebook = vim.json.decode(content)
  vim.fn.delete(temp_path)

  return notebook.cells[1].source
end

-- Helper to get tests directory path
local function tests_dir()
  return vim.fn.fnamemodify(debug.getinfo(1, 'S').source:sub(2), ':p:h')
end

-- Helper to read raw JSON from file
local function read_json(path)
  local content = table.concat(vim.fn.readfile(path), '\n')
  return vim.json.decode(content)
end

-- Deep compare two tables, returning differences
local function deep_equal(a, b, path)
  path = path or ''

  if type(a) ~= type(b) then
    return false, string.format('%s: type mismatch (%s vs %s)', path, type(a), type(b))
  end

  if type(a) ~= 'table' then
    if a ~= b then
      return false, string.format('%s: value mismatch (%s vs %s)', path, vim.inspect(a), vim.inspect(b))
    end
    return true
  end

  -- Check all keys in a
  for k, v in pairs(a) do
    local new_path = path == '' and tostring(k) or (path .. '.' .. tostring(k))
    local ok, err = deep_equal(v, b[k], new_path)
    if not ok then
      return false, err
    end
  end

  -- Check for keys in b not in a
  for k, _ in pairs(b) do
    if a[k] == nil then
      local new_path = path == '' and tostring(k) or (path .. '.' .. tostring(k))
      return false, string.format('%s: missing in first table', new_path)
    end
  end

  return true
end

--------------------------------------------------------------------------------
-- Test: Source splitting matches nbformat behavior
-- This is critical for compatibility with Jupyter and other tools
--------------------------------------------------------------------------------
h.run_test('source_splitting_matches_nbformat', function()
  for _, case in ipairs(SOURCE_SPLIT_CASES) do
    local name, source, expected = case[1], case[2], case[3]
    local actual = get_written_source_lines(source)

    local ok, err = arrays_equal(actual, expected)
    if not ok then
      error(string.format('source_split %s: %s\n  source: %q\n  expected: %s\n  actual: %s',
        name, err, source, vim.inspect(expected), vim.inspect(actual)))
    end
  end
end)

--------------------------------------------------------------------------------
-- Test: Basic round-trip preserves cell source
--------------------------------------------------------------------------------
h.run_test('roundtrip_preserves_cell_source', function()
  local path = tests_dir() .. '/fixtures/simple.ipynb'
  local temp_path = vim.fn.tempname() .. '.ipynb'

  -- Read original
  local cells, metadata = io_mod.read_ipynb(path)

  -- Store original sources
  local original_sources = {}
  for i, cell in ipairs(cells) do
    original_sources[i] = cell.source
  end

  -- Write to temp
  io_mod.write_ipynb(temp_path, cells, metadata)

  -- Read back
  local cells2, _ = io_mod.read_ipynb(temp_path)

  -- Compare cell sources
  h.assert_eq(#cells2, #cells, 'Cell count should match')
  for i, cell in ipairs(cells2) do
    h.assert_eq(cell.source, original_sources[i], string.format('Cell %d source should match', i))
  end

  -- Cleanup
  vim.fn.delete(temp_path)
end)

--------------------------------------------------------------------------------
-- Test: Round-trip preserves cell types
--------------------------------------------------------------------------------
h.run_test('roundtrip_preserves_cell_types', function()
  local path = tests_dir() .. '/fixtures/mixed.ipynb'
  local temp_path = vim.fn.tempname() .. '.ipynb'

  local cells, metadata = io_mod.read_ipynb(path)

  local original_types = {}
  for i, cell in ipairs(cells) do
    original_types[i] = cell.type
  end

  io_mod.write_ipynb(temp_path, cells, metadata)
  local cells2, _ = io_mod.read_ipynb(temp_path)

  for i, cell in ipairs(cells2) do
    h.assert_eq(cell.type, original_types[i], string.format('Cell %d type should match', i))
  end

  vim.fn.delete(temp_path)
end)

--------------------------------------------------------------------------------
-- Test: Metadata preservation (kernelspec)
--------------------------------------------------------------------------------
h.run_test('roundtrip_preserves_kernelspec', function()
  local path = tests_dir() .. '/fixtures/mixed.ipynb'
  local temp_path = vim.fn.tempname() .. '.ipynb'

  local cells, metadata = io_mod.read_ipynb(path)
  io_mod.write_ipynb(temp_path, cells, metadata)

  local raw = read_json(temp_path)

  h.assert_eq(raw.metadata.kernelspec.name, 'python3', 'Kernelspec name preserved')
  h.assert_eq(raw.metadata.kernelspec.display_name, 'Python 3', 'Kernelspec display_name preserved')

  vim.fn.delete(temp_path)
end)

--------------------------------------------------------------------------------
-- Test: Rich metadata preservation (Colab, accelerator, widgets)
--------------------------------------------------------------------------------
h.run_test('roundtrip_preserves_rich_metadata', function()
  local path = tests_dir() .. '/fixtures/rich_metadata.ipynb'
  local temp_path = vim.fn.tempname() .. '.ipynb'

  local original = read_json(path)
  local cells, metadata = io_mod.read_ipynb(path)
  io_mod.write_ipynb(temp_path, cells, metadata)
  local written = read_json(temp_path)

  -- Check Colab metadata preserved
  h.assert_true(written.metadata.colab ~= nil, 'Colab metadata should be preserved')
  h.assert_eq(written.metadata.colab.gpuType, 'T4', 'Colab gpuType should be preserved')

  -- Check accelerator preserved
  h.assert_eq(written.metadata.accelerator, 'GPU', 'Accelerator should be preserved')

  -- Check widgets preserved
  h.assert_true(written.metadata.widgets ~= nil, 'Widgets metadata should be preserved')

  -- Check language_info preserved with all fields
  h.assert_eq(written.metadata.language_info.file_extension, '.py', 'language_info.file_extension preserved')
  h.assert_eq(written.metadata.language_info.mimetype, 'text/x-python', 'language_info.mimetype preserved')

  vim.fn.delete(temp_path)
end)

--------------------------------------------------------------------------------
-- Test: Cell ID preservation (nbformat 4.5+)
--------------------------------------------------------------------------------
h.run_test('roundtrip_preserves_cell_ids', function()
  local path = tests_dir() .. '/fixtures/rich_metadata.ipynb'
  local temp_path = vim.fn.tempname() .. '.ipynb'

  local original = read_json(path)
  local cells, metadata = io_mod.read_ipynb(path)
  io_mod.write_ipynb(temp_path, cells, metadata)
  local written = read_json(temp_path)

  -- Check each cell ID is preserved
  for i, orig_cell in ipairs(original.cells) do
    h.assert_eq(written.cells[i].id, orig_cell.id,
      string.format('Cell %d ID should be preserved (%s)', i, orig_cell.id))
  end

  vim.fn.delete(temp_path)
end)

--------------------------------------------------------------------------------
-- Test: Cell metadata preservation
--------------------------------------------------------------------------------
h.run_test('roundtrip_preserves_cell_metadata', function()
  local path = tests_dir() .. '/fixtures/rich_metadata.ipynb'
  local temp_path = vim.fn.tempname() .. '.ipynb'

  local original = read_json(path)
  local cells, metadata = io_mod.read_ipynb(path)
  io_mod.write_ipynb(temp_path, cells, metadata)
  local written = read_json(temp_path)

  -- Check cell metadata preserved
  h.assert_eq(written.cells[1].metadata.id, 'colab_cell_1', 'Cell 1 Colab ID preserved')
  h.assert_true(written.cells[1].metadata.tags ~= nil, 'Cell 1 tags preserved')
  h.assert_eq(written.cells[1].metadata.tags[1], 'intro', 'Cell 1 tag value preserved')

  -- Check execution metadata
  h.assert_true(written.cells[2].metadata.executionInfo ~= nil, 'executionInfo preserved')
  h.assert_eq(written.cells[2].metadata.scrolled, true, 'scrolled metadata preserved')

  vim.fn.delete(temp_path)
end)

--------------------------------------------------------------------------------
-- Test: Output preservation
--------------------------------------------------------------------------------
h.run_test('roundtrip_preserves_outputs', function()
  local path = tests_dir() .. '/fixtures/rich_metadata.ipynb'
  local temp_path = vim.fn.tempname() .. '.ipynb'

  local original = read_json(path)
  local cells, metadata = io_mod.read_ipynb(path)
  io_mod.write_ipynb(temp_path, cells, metadata)
  local written = read_json(temp_path)

  -- Check outputs preserved
  h.assert_eq(#written.cells[2].outputs, 1, 'Output count preserved')
  h.assert_eq(written.cells[2].outputs[1].output_type, 'stream', 'Output type preserved')
  h.assert_eq(written.cells[2].outputs[1].name, 'stdout', 'Output name preserved')
  h.assert_eq(written.cells[2].outputs[1].text[1], 'hello\n', 'Output text preserved')

  vim.fn.delete(temp_path)
end)

--------------------------------------------------------------------------------
-- Test: Execution count preservation
--------------------------------------------------------------------------------
h.run_test('roundtrip_preserves_execution_count', function()
  local path = tests_dir() .. '/fixtures/rich_metadata.ipynb'
  local temp_path = vim.fn.tempname() .. '.ipynb'

  local original = read_json(path)
  local cells, metadata = io_mod.read_ipynb(path)
  io_mod.write_ipynb(temp_path, cells, metadata)
  local written = read_json(temp_path)

  h.assert_eq(written.cells[2].execution_count, 1, 'Execution count preserved')

  vim.fn.delete(temp_path)
end)

--------------------------------------------------------------------------------
-- Test: Empty cell handling
--------------------------------------------------------------------------------
h.run_test('roundtrip_handles_empty_cells', function()
  local path = tests_dir() .. '/fixtures/rich_metadata.ipynb'
  local temp_path = vim.fn.tempname() .. '.ipynb'

  local cells, metadata = io_mod.read_ipynb(path)
  io_mod.write_ipynb(temp_path, cells, metadata)
  local written = read_json(temp_path)

  -- Cell 3 (index 2 in 0-based) is empty
  h.assert_eq(#written.cells[3].source, 0, 'Empty cell has empty source array')

  vim.fn.delete(temp_path)
end)

--------------------------------------------------------------------------------
-- Test: Unicode preservation
--------------------------------------------------------------------------------
h.run_test('roundtrip_preserves_unicode', function()
  local path = tests_dir() .. '/fixtures/rich_metadata.ipynb'
  local temp_path = vim.fn.tempname() .. '.ipynb'

  local cells, metadata = io_mod.read_ipynb(path)

  -- Find unicode cell (cell 4, 0-indexed)
  local unicode_cell = cells[4]
  h.assert_true(unicode_cell.source:find('ðŸŽ‰') ~= nil, 'Unicode emoji in source')
  h.assert_true(unicode_cell.source:find('æ—¥æœ¬èªž') ~= nil, 'Japanese in source')
  h.assert_true(unicode_cell.source:find('âˆ«âˆ‘âˆ') ~= nil, 'Math symbols in source')

  io_mod.write_ipynb(temp_path, cells, metadata)
  local cells2, _ = io_mod.read_ipynb(temp_path)

  h.assert_eq(cells2[4].source, unicode_cell.source, 'Unicode preserved through round-trip')

  vim.fn.delete(temp_path)
end)

--------------------------------------------------------------------------------
-- Test: Trailing newline handling
--------------------------------------------------------------------------------
h.run_test('roundtrip_handles_trailing_newlines', function()
  local path = tests_dir() .. '/fixtures/rich_metadata.ipynb'
  local temp_path = vim.fn.tempname() .. '.ipynb'

  local original = read_json(path)
  local cells, metadata = io_mod.read_ipynb(path)
  io_mod.write_ipynb(temp_path, cells, metadata)
  local written = read_json(temp_path)

  -- Cell 5 (index 4 in 0-based) has trailing newline
  -- Original source array ends with "\n"
  local orig_last = original.cells[5].source[#original.cells[5].source]
  local written_last = written.cells[5].source[#written.cells[5].source]

  -- Both should end the same way
  h.assert_eq(written_last:sub(-1), orig_last:sub(-1),
    'Trailing newline handling consistent')

  vim.fn.delete(temp_path)
end)

--------------------------------------------------------------------------------
-- Test: nbformat version preservation
--------------------------------------------------------------------------------
h.run_test('roundtrip_preserves_nbformat', function()
  local path = tests_dir() .. '/fixtures/rich_metadata.ipynb'
  local temp_path = vim.fn.tempname() .. '.ipynb'

  local original = read_json(path)
  local cells, metadata = io_mod.read_ipynb(path)
  io_mod.write_ipynb(temp_path, cells, metadata)
  local written = read_json(temp_path)

  h.assert_eq(written.nbformat, original.nbformat, 'nbformat preserved')
  h.assert_eq(written.nbformat_minor, original.nbformat_minor, 'nbformat_minor preserved')

  vim.fn.delete(temp_path)
end)

--------------------------------------------------------------------------------
-- Test: Read-back produces valid JSON
--------------------------------------------------------------------------------
h.run_test('written_notebook_is_valid_json', function()
  local path = tests_dir() .. '/fixtures/rich_metadata.ipynb'
  local temp_path = vim.fn.tempname() .. '.ipynb'

  local cells, metadata = io_mod.read_ipynb(path)
  io_mod.write_ipynb(temp_path, cells, metadata)

  -- Should not throw
  local ok, result = pcall(read_json, temp_path)
  h.assert_true(ok, 'Written file should be valid JSON')
  h.assert_true(result.cells ~= nil, 'Should have cells array')
  h.assert_true(result.metadata ~= nil, 'Should have metadata')

  vim.fn.delete(temp_path)
end)

--------------------------------------------------------------------------------
-- Test: Can read back what we wrote
--------------------------------------------------------------------------------
h.run_test('can_read_written_notebook', function()
  local path = tests_dir() .. '/fixtures/simple.ipynb'
  local temp_path = vim.fn.tempname() .. '.ipynb'

  local cells, metadata = io_mod.read_ipynb(path)
  io_mod.write_ipynb(temp_path, cells, metadata)

  -- Should be able to read it back without error
  local ok, err = pcall(function()
    local cells2, metadata2 = io_mod.read_ipynb(temp_path)
    return cells2, metadata2
  end)

  h.assert_true(ok, 'Should be able to read written notebook: ' .. tostring(err))

  vim.fn.delete(temp_path)
end)

--------------------------------------------------------------------------------
-- Test: All fixtures round-trip successfully
--------------------------------------------------------------------------------
h.run_test('all_fixtures_roundtrip', function()
  local fixtures = {
    'simple.ipynb',
    'mixed.ipynb',
    'three_cells.ipynb',
    'lsp_test.ipynb',
    'rich_metadata.ipynb',
  }

  for _, fixture in ipairs(fixtures) do
    local path = tests_dir() .. '/fixtures/' .. fixture
    local temp_path = vim.fn.tempname() .. '.ipynb'

    local ok, err = pcall(function()
      local cells, metadata = io_mod.read_ipynb(path)
      io_mod.write_ipynb(temp_path, cells, metadata)
      local cells2, metadata2 = io_mod.read_ipynb(temp_path)

      -- Basic sanity checks
      assert(#cells2 == #cells, fixture .. ': cell count mismatch')
      for i, cell in ipairs(cells) do
        assert(cells2[i].source == cell.source, fixture .. ': cell ' .. i .. ' source mismatch')
        assert(cells2[i].type == cell.type, fixture .. ': cell ' .. i .. ' type mismatch')
      end
    end)

    h.assert_true(ok, fixture .. ' should round-trip: ' .. tostring(err))
    vim.fn.delete(temp_path)
  end
end)

--------------------------------------------------------------------------------
-- Test: jupytext format round-trip (facade buffer format)
--------------------------------------------------------------------------------
h.run_test('jupytext_format_roundtrip', function()
  local original_cells = {
    { type = 'markdown', source = '# Header\n\nSome text', metadata = {} },
    { type = 'code', source = 'x = 1\ny = 2', metadata = {}, outputs = {} },
    { type = 'code', source = '', metadata = {}, outputs = {} },  -- empty cell
  }

  local lines = io_mod.cells_to_jupytext(original_cells)
  local parsed_cells = io_mod.jupytext_to_cells(lines)

  h.assert_eq(#parsed_cells, #original_cells, 'Cell count matches')

  for i, orig in ipairs(original_cells) do
    h.assert_eq(parsed_cells[i].type, orig.type, 'Cell ' .. i .. ' type matches')
    h.assert_eq(parsed_cells[i].source, orig.source, 'Cell ' .. i .. ' source matches')
  end
end)

--------------------------------------------------------------------------------
-- nbformat test suite fixtures
-- These are official test notebooks from jupyter/nbformat
--------------------------------------------------------------------------------

-- Helper: roundtrip a notebook and verify cell sources match
local function roundtrip_verify_sources(path, name)
  local temp_path = vim.fn.tempname() .. '.ipynb'

  local cells, metadata = io_mod.read_ipynb(path)
  local original_sources = {}
  for i, cell in ipairs(cells) do
    original_sources[i] = cell.source
  end

  io_mod.write_ipynb(temp_path, cells, metadata)
  local cells2, _ = io_mod.read_ipynb(temp_path)

  h.assert_eq(#cells2, #cells, name .. ': cell count should match')
  for i, cell in ipairs(cells2) do
    h.assert_eq(cell.source, original_sources[i],
      string.format('%s: cell %d source should match', name, i))
  end

  vim.fn.delete(temp_path)
end

-- Helper: roundtrip and compare JSON structure
local function roundtrip_verify_json(path, name, checks)
  local temp_path = vim.fn.tempname() .. '.ipynb'

  local original = read_json(path)
  local cells, metadata = io_mod.read_ipynb(path)
  io_mod.write_ipynb(temp_path, cells, metadata)
  local written = read_json(temp_path)

  -- Run custom checks
  if checks then
    checks(original, written)
  end

  vim.fn.delete(temp_path)
end

--------------------------------------------------------------------------------
-- Test: nbformat test4.5.ipynb (v4.5 with cell IDs)
--------------------------------------------------------------------------------
h.run_test('nbformat_test4_5_roundtrip', function()
  local path = tests_dir() .. '/fixtures/nbformat/test4.5.ipynb'
  roundtrip_verify_sources(path, 'test4.5')

  roundtrip_verify_json(path, 'test4.5', function(original, written)
    -- Cell IDs should be preserved
    for i, orig_cell in ipairs(original.cells) do
      h.assert_eq(written.cells[i].id, orig_cell.id,
        string.format('test4.5: cell %d ID should be preserved', i))
    end

    -- nbformat version should be preserved
    h.assert_eq(written.nbformat, 4, 'test4.5: nbformat should be 4')
    h.assert_eq(written.nbformat_minor, 5, 'test4.5: nbformat_minor should be 5')

    -- Kernelspec should be preserved
    h.assert_eq(written.metadata.kernelspec.name, 'python3', 'test4.5: kernelspec name')
    h.assert_eq(written.metadata.kernelspec.display_name, 'Python 3 (ipykernel)',
      'test4.5: kernelspec display_name')
  end)
end)

--------------------------------------------------------------------------------
-- Test: nbformat test4.ipynb (v4.0, no cell IDs - should auto-upgrade)
--------------------------------------------------------------------------------
h.run_test('nbformat_test4_roundtrip_autoupgrade', function()
  local path = tests_dir() .. '/fixtures/nbformat/test4.ipynb'
  roundtrip_verify_sources(path, 'test4')

  roundtrip_verify_json(path, 'test4', function(original, written)
    -- Original has no cell IDs (v4.0)
    h.assert_eq(original.nbformat_minor, 0, 'test4: original is v4.0')
    h.assert_true(original.cells[1].id == nil, 'test4: original has no cell IDs')

    -- After round-trip, should be upgraded to v4.5 with cell IDs
    h.assert_eq(written.nbformat, 4, 'test4: nbformat should be 4')
    h.assert_true(written.nbformat_minor >= 5, 'test4: should be upgraded to 4.5+')

    -- All cells should now have IDs
    for i, cell in ipairs(written.cells) do
      h.assert_true(cell.id ~= nil, string.format('test4: cell %d should have ID after upgrade', i))
      h.assert_true(#cell.id > 0, string.format('test4: cell %d ID should be non-empty', i))
    end
  end)
end)

--------------------------------------------------------------------------------
-- Test: nbformat test4jupyter_metadata.ipynb (jupyter cell metadata)
--------------------------------------------------------------------------------
h.run_test('nbformat_jupyter_metadata_roundtrip', function()
  local path = tests_dir() .. '/fixtures/nbformat/test4jupyter_metadata.ipynb'
  roundtrip_verify_sources(path, 'test4jupyter_metadata')

  roundtrip_verify_json(path, 'test4jupyter_metadata', function(original, written)
    -- Jupyter cell metadata should be preserved
    local orig_meta = original.cells[1].metadata.jupyter
    local written_meta = written.cells[1].metadata.jupyter

    h.assert_true(written_meta ~= nil, 'jupyter metadata should be preserved')
    h.assert_eq(written_meta.outputs_hidden, orig_meta.outputs_hidden,
      'outputs_hidden should be preserved')
    h.assert_eq(written_meta.source_hidden, orig_meta.source_hidden,
      'source_hidden should be preserved')
  end)
end)

--------------------------------------------------------------------------------
-- Test: nbformat test4custom.ipynb (custom MIME types)
--------------------------------------------------------------------------------
h.run_test('nbformat_custom_mime_roundtrip', function()
  local path = tests_dir() .. '/fixtures/nbformat/test4custom.ipynb'
  roundtrip_verify_sources(path, 'test4custom')

  roundtrip_verify_json(path, 'test4custom', function(original, written)
    -- Custom MIME output should be preserved
    local orig_output = original.cells[1].outputs[1]
    local written_output = written.cells[1].outputs[1]

    h.assert_eq(written_output.output_type, orig_output.output_type,
      'output_type should be preserved')

    -- The custom MIME type data should be preserved
    local custom_key = 'application/vnd.raw.v1+json'
    h.assert_true(written_output.data[custom_key] ~= nil,
      'custom MIME type data should be preserved')
  end)
end)

--------------------------------------------------------------------------------
-- Test: nbformat many_tracebacks.ipynb (error outputs with ANSI)
--------------------------------------------------------------------------------
h.run_test('nbformat_tracebacks_roundtrip', function()
  local path = tests_dir() .. '/fixtures/nbformat/many_tracebacks.ipynb'
  roundtrip_verify_sources(path, 'many_tracebacks')

  roundtrip_verify_json(path, 'many_tracebacks', function(original, written)
    -- Error output should be preserved
    local orig_output = original.cells[1].outputs[1]
    local written_output = written.cells[1].outputs[1]

    h.assert_eq(written_output.output_type, 'error', 'output_type should be error')
    h.assert_eq(written_output.ename, orig_output.ename, 'ename should be preserved')
    h.assert_eq(written_output.evalue, orig_output.evalue, 'evalue should be preserved')

    -- Traceback with ANSI codes should be preserved
    h.assert_true(#written_output.traceback > 0, 'traceback should have entries')
    h.assert_eq(#written_output.traceback, #orig_output.traceback,
      'traceback length should match')

    -- Check ANSI codes are preserved (they contain escape sequences)
    for i, tb in ipairs(orig_output.traceback) do
      h.assert_eq(written_output.traceback[i], tb,
        string.format('traceback[%d] should be preserved exactly', i))
    end
  end)
end)

--------------------------------------------------------------------------------
-- Test: Full JSON structure equality (v4.5+ notebooks)
-- These notebooks should round-trip with identical JSON structure
--------------------------------------------------------------------------------
h.run_test('nbformat_test4_5_full_json_equality', function()
  local path = tests_dir() .. '/fixtures/nbformat/test4.5.ipynb'
  local temp_path = vim.fn.tempname() .. '.ipynb'

  local original = read_json(path)
  local cells, metadata = io_mod.read_ipynb(path)
  io_mod.write_ipynb(temp_path, cells, metadata)
  local written = read_json(temp_path)

  local ok, err = deep_equal(original, written, '')
  h.assert_true(ok, 'test4.5.ipynb full JSON equality: ' .. (err or ''))

  vim.fn.delete(temp_path)
end)

h.run_test('nbformat_jupyter_metadata_full_json_equality', function()
  local path = tests_dir() .. '/fixtures/nbformat/test4jupyter_metadata.ipynb'
  local temp_path = vim.fn.tempname() .. '.ipynb'

  local original = read_json(path)
  local cells, metadata = io_mod.read_ipynb(path)
  io_mod.write_ipynb(temp_path, cells, metadata)
  local written = read_json(temp_path)

  -- This one is v4.0, so it will be upgraded - skip cell ID comparison
  -- but check everything else matches after accounting for upgrade
  -- Actually, let's just verify the cells content matches exactly
  for i, orig_cell in ipairs(original.cells) do
    local written_cell = written.cells[i]
    -- Compare source
    local ok, err = deep_equal(orig_cell.source, written_cell.source, 'cells[' .. i .. '].source')
    h.assert_true(ok, 'jupyter_metadata source: ' .. (err or ''))
    -- Compare metadata
    ok, err = deep_equal(orig_cell.metadata, written_cell.metadata, 'cells[' .. i .. '].metadata')
    h.assert_true(ok, 'jupyter_metadata metadata: ' .. (err or ''))
    -- Compare outputs if present
    if orig_cell.outputs then
      ok, err = deep_equal(orig_cell.outputs, written_cell.outputs, 'cells[' .. i .. '].outputs')
      h.assert_true(ok, 'jupyter_metadata outputs: ' .. (err or ''))
    end
  end

  vim.fn.delete(temp_path)
end)

h.run_test('nbformat_custom_mime_full_json_equality', function()
  local path = tests_dir() .. '/fixtures/nbformat/test4custom.ipynb'
  local temp_path = vim.fn.tempname() .. '.ipynb'

  local original = read_json(path)
  local cells, metadata = io_mod.read_ipynb(path)
  io_mod.write_ipynb(temp_path, cells, metadata)
  local written = read_json(temp_path)

  -- Compare cell contents (source, metadata, outputs) exactly
  for i, orig_cell in ipairs(original.cells) do
    local written_cell = written.cells[i]
    local ok, err = deep_equal(orig_cell.source, written_cell.source, 'cells[' .. i .. '].source')
    h.assert_true(ok, 'custom_mime source: ' .. (err or ''))
    ok, err = deep_equal(orig_cell.metadata, written_cell.metadata, 'cells[' .. i .. '].metadata')
    h.assert_true(ok, 'custom_mime metadata: ' .. (err or ''))
    if orig_cell.outputs then
      ok, err = deep_equal(orig_cell.outputs, written_cell.outputs, 'cells[' .. i .. '].outputs')
      h.assert_true(ok, 'custom_mime outputs: ' .. (err or ''))
    end
  end

  vim.fn.delete(temp_path)
end)

h.run_test('nbformat_tracebacks_full_json_equality', function()
  local path = tests_dir() .. '/fixtures/nbformat/many_tracebacks.ipynb'
  local temp_path = vim.fn.tempname() .. '.ipynb'

  local original = read_json(path)
  local cells, metadata = io_mod.read_ipynb(path)
  io_mod.write_ipynb(temp_path, cells, metadata)
  local written = read_json(temp_path)

  -- Compare full notebook structure
  -- Note: this is v4.4, so will be upgraded to 4.5 with cell IDs added
  -- Check metadata preservation
  local ok, err = deep_equal(original.metadata, written.metadata, 'metadata')
  h.assert_true(ok, 'tracebacks metadata: ' .. (err or ''))

  -- Check cell contents exactly
  for i, orig_cell in ipairs(original.cells) do
    local written_cell = written.cells[i]
    ok, err = deep_equal(orig_cell.source, written_cell.source, 'cells[' .. i .. '].source')
    h.assert_true(ok, 'tracebacks source: ' .. (err or ''))
    ok, err = deep_equal(orig_cell.metadata, written_cell.metadata, 'cells[' .. i .. '].metadata')
    h.assert_true(ok, 'tracebacks metadata: ' .. (err or ''))
    if orig_cell.outputs then
      ok, err = deep_equal(orig_cell.outputs, written_cell.outputs, 'cells[' .. i .. '].outputs')
      h.assert_true(ok, 'tracebacks outputs: ' .. (err or ''))
    end
  end

  vim.fn.delete(temp_path)
end)

--------------------------------------------------------------------------------
-- Test: All nbformat fixtures round-trip without error
--------------------------------------------------------------------------------
h.run_test('all_nbformat_fixtures_roundtrip', function()
  local nbformat_fixtures = {
    'test4.5.ipynb',
    'test4.ipynb',
    'test4jupyter_metadata.ipynb',
    'test4custom.ipynb',
    'many_tracebacks.ipynb',
  }

  for _, fixture in ipairs(nbformat_fixtures) do
    local path = tests_dir() .. '/fixtures/nbformat/' .. fixture
    local temp_path = vim.fn.tempname() .. '.ipynb'

    local ok, err = pcall(function()
      local cells, metadata = io_mod.read_ipynb(path)
      io_mod.write_ipynb(temp_path, cells, metadata)
      local cells2, metadata2 = io_mod.read_ipynb(temp_path)

      -- Basic sanity checks
      assert(#cells2 == #cells, fixture .. ': cell count mismatch')
      for i, cell in ipairs(cells) do
        assert(cells2[i].source == cell.source, fixture .. ': cell ' .. i .. ' source mismatch')
        assert(cells2[i].type == cell.type, fixture .. ': cell ' .. i .. ' type mismatch')
      end
    end)

    h.assert_true(ok, 'nbformat/' .. fixture .. ' should round-trip: ' .. tostring(err))
    vim.fn.delete(temp_path)
  end
end)

--------------------------------------------------------------------------------
-- Print summary and exit
--------------------------------------------------------------------------------
local success = h.summary()
if success then
  vim.cmd('qa!')
else
  vim.cmd('cquit 1')
end
